{
  "version": 3,
  "sources": ["../../react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js"],
  "sourcesContent": ["import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[\"useId\".toString()];\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idRef.current;\n}\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsedSize = 0,\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = null,\n  minSize,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const panelId = useUniqueId(idFromProps);\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    units,\n    unregisterPanel\n  } = context;\n  if (minSize == null) {\n    if (units === \"percentages\") {\n      // Mimics legacy default value for percentage based panel groups\n      minSize = 10;\n    } else {\n      // There is no meaningful minimum pixel default we can provide\n      minSize = 0;\n    }\n  }\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onCollapse,\n    onResize\n  });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n  const style = getPanelStyle(panelId, defaultSize);\n  const committedValuesRef = useRef({\n    size: parseSizeFromStyle(style)\n  });\n  const panelDataRef = useRef({\n    callbacksRef,\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    idWasAutoGenerated: idFromProps == null,\n    maxSize,\n    minSize,\n    order\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n    panelDataRef.current.callbacksRef = callbacksRef;\n    panelDataRef.current.collapsedSize = collapsedSize;\n    panelDataRef.current.collapsible = collapsible;\n    panelDataRef.current.defaultSize = defaultSize;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idWasAutoGenerated = idFromProps == null;\n    panelDataRef.current.maxSize = maxSize;\n    panelDataRef.current.minSize = minSize;\n    panelDataRef.current.order = order;\n  });\n  useIsomorphicLayoutEffect(() => {\n    registerPanel(panelId, panelDataRef);\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => collapsePanel(panelId),\n    expand: () => expandPanel(panelId),\n    getCollapsed() {\n      return committedValuesRef.current.size === 0;\n    },\n    getId() {\n      return panelId;\n    },\n    getSize(units) {\n      return getPanelSize(panelId, units);\n    },\n    resize: (percentage, units) => resizePanel(panelId, percentage, units)\n  }), [collapsePanel, expandPanel, getPanelSize, panelId, resizePanel]);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps\n    }\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style) {\n  const {\n    flexGrow\n  } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\n\nconst PRECISION = 10;\n\nfunction adjustByDelta(event, committedValues, idBefore, idAfter, deltaPixels, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n  const {\n    id: groupId,\n    panels,\n    units\n  } = committedValues;\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const {\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const nextSizes = baseSizes.concat();\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize + Math.abs(deltaPixels), event);\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n      deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n  let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize - deltaRemaining, event);\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n      deltaApplied += baseSize - nextSize;\n      nextSizes[index] = nextSize;\n      if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(deltaPixels).toPrecision(PRECISION), undefined, {\n        numeric: true\n      }) >= 0) {\n        break;\n      }\n    }\n    if (deltaPixels < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = deltaPixels < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n  return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n  sizes.forEach((size, index) => {\n    const panelRef = panelsArray[index];\n    if (!panelRef) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n    const {\n      callbacksRef,\n      collapsedSize,\n      collapsible,\n      id\n    } = panelRef.current;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n      const {\n        onCollapse,\n        onResize\n      } = callbacksRef.current;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && onCollapse) {\n        if ((lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n          onCollapse(false);\n        } else if (lastNotifiedSize !== collapsedSize && size === collapsedSize) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\nfunction calculateDefaultLayout({\n  groupId,\n  panels,\n  units\n}) {\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const sizes = Array(panelsArray.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Assigning default sizes requires a couple of passes:\n  // First, all panels with defaultSize should be set as-is\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const {\n      defaultSize\n    } = panel.current;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      sizes[index] = units === \"pixels\" ? defaultSize / groupSizePixels * 100 : defaultSize;\n      remainingSize -= sizes[index];\n    }\n  }\n\n  // Remaining total size should be distributed evenly between panels\n  // This may require two passes, depending on min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    let {\n      defaultSize,\n      id,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (defaultSize != null) {\n      continue;\n    }\n    if (units === \"pixels\") {\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const remainingPanels = panelsArray.length - numPanelsWithSizes;\n    const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, remainingSize / remainingPanels));\n    sizes[index] = size;\n    numPanelsWithSizes++;\n    remainingSize -= size;\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize !== 0) {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, sizes[index] + remainingSize));\n      if (size !== sizes[index]) {\n        remainingSize -= size - sizes[index];\n        sizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // Finally, if there is still left-over size, log an error\n  if (Math.abs(remainingSize).toFixed(3) !== \"0.000\") {\n    {\n      console.error(`Invalid panel group configuration; default panel sizes should total 100% but was ${(100 - remainingSize).toFixed(1)}%. This can cause the cursor to become misaligned while dragging.`);\n    }\n  }\n  return sizes;\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n  return [idBefore, idAfter];\n}\nfunction getAvailableGroupSizePixels(groupId) {\n  const panelGroupElement = getPanelGroup(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandlesForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n  return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelGroup(id) {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandle(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleIndex(id) {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index ?? null;\n}\nfunction getResizeHandles() {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = panelsArray[index]?.current?.id ?? null;\n  const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n  return [idBefore, idAfter];\n}\nfunction panelsMapToSortedArray(panels) {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize, event = null) {\n  let {\n    collapsedSize,\n    collapsible,\n    maxSize,\n    minSize\n  } = panel.current;\n  if (units === \"pixels\") {\n    collapsedSize = collapsedSize / groupSizePixels * 100;\n    if (maxSize != null) {\n      maxSize = maxSize / groupSizePixels * 100;\n    }\n    minSize = minSize / groupSizePixels * 100;\n  }\n  if (collapsible) {\n    if (prevSize > collapsedSize) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSize <= minSize / 2 + collapsedSize) {\n        return collapsedSize;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSize < minSize) {\n          return collapsedSize;\n        }\n      }\n    }\n  }\n  return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\nfunction validatePanelProps(units, panelData) {\n  const {\n    collapsible,\n    defaultSize,\n    maxSize,\n    minSize\n  } = panelData.current;\n\n  // Basic props validation\n  if (minSize < 0 || units === \"percentages\" && minSize > 100) {\n    {\n      console.error(`Invalid Panel minSize provided, ${minSize}`);\n    }\n    panelData.current.minSize = 0;\n  }\n  if (maxSize != null) {\n    if (maxSize < 0 || units === \"percentages\" && maxSize > 100) {\n      {\n        console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n      }\n      panelData.current.maxSize = null;\n    }\n  }\n  if (defaultSize !== null) {\n    if (defaultSize < 0 || units === \"percentages\" && defaultSize > 100) {\n      {\n        console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n      }\n      panelData.current.defaultSize = null;\n    } else if (defaultSize < minSize && !collapsible) {\n      {\n        console.error(`Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = minSize;\n    } else if (maxSize != null && defaultSize > maxSize) {\n      {\n        console.error(`Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = maxSize;\n    }\n  }\n}\nfunction validatePanelGroupLayout({\n  groupId,\n  panels,\n  nextSizes,\n  prevSizes,\n  units\n}) {\n  // Clone because this method modifies\n  nextSizes = [...nextSizes];\n  const panelsArray = panelsMapToSortedArray(panels);\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  let remainingSize = 0;\n\n  // First, check all of the proposed sizes against the min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n    const nextSize = nextSizes[index];\n    const safeNextSize = safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize);\n    if (nextSize != safeNextSize) {\n      remainingSize += nextSize - safeNextSize;\n      nextSizes[index] = safeNextSize;\n      {\n        console.error(`Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n      }\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSizes[index] + remainingSize));\n      if (size !== nextSizes[index]) {\n        remainingSize -= size - nextSizes[index];\n        nextSizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // If we still have remainder, the requested layout wasn't valid and we should warn about it\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    {\n      console.error(`\"Invalid panel group configuration; default panel sizes should total 100% but was ${100 - remainingSize}%`);\n    }\n  }\n  return nextSizes;\n}\n\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse\n}) {\n  useEffect(() => {\n    const {\n      direction,\n      panels\n    } = committedValuesRef.current;\n    const groupElement = getPanelGroup(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const {\n      height,\n      width\n    } = groupElement.getBoundingClientRect();\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      let currentMinSize = 0;\n      let currentMaxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach(panelData => {\n        const {\n          id,\n          maxSize,\n          minSize\n        } = panelData.current;\n        if (id === idBefore) {\n          currentMinSize = minSize;\n          currentMaxSize = maxSize != null ? maxSize : 100;\n        } else {\n          totalMinSize += minSize;\n          totalMaxSize += maxSize != null ? maxSize : 100;\n        }\n      });\n      const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(currentMinSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelsArray.findIndex(panel => panel.current.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelsArray[index];\n                const size = sizes[index];\n                if (size != null) {\n                  let delta = 0;\n                  if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                    delta = direction === \"horizontal\" ? width : height;\n                  } else {\n                    delta = -(direction === \"horizontal\" ? width : height);\n                  }\n                  const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                  if (sizes !== nextSizes) {\n                    setSizes(nextSizes);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n        handle.removeEventListener(\"keydown\", onKeyDown);\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, groupId, panels, panelSizeBeforeCollapse, setSizes, sizes]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const handles = getResizeHandles();\n            const index = getResizeHandleIndex(handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n  const isHorizontal = direction === \"horizontal\";\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n  const handleElement = getResizeHandle(handleId);\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(panel => panel.current.id === targetPanelId);\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n        movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n  }\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      minSize,\n      order\n    } = panel.current;\n    return order ? `${order}:${minSize}` : `${minSize}`;\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelLayout(autoSaveId, panels, storage) {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nconst debounceMap = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n  units = \"percentages\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [activeHandleId, setActiveHandleId] = useState(null);\n  const [panels, setPanels] = useState(new Map());\n\n  // When resizing is done via mouse/touch event–\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef(null);\n  const devWarningsRef = useRef({\n    didLogDefaultSizeWarning: false,\n    didLogIdAndOrderWarning: false,\n    didLogInvalidLayoutWarning: false,\n    prevPanelIds: []\n  });\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onLayout\n  });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef({\n    direction,\n    id: groupId,\n    panels,\n    sizes,\n    units\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => groupId,\n    getLayout: unitsFromParams => {\n      const {\n        sizes,\n        units: unitsFromProps\n      } = committedValuesRef.current;\n      const units = unitsFromParams ?? unitsFromProps;\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        return sizes.map(size => size / 100 * groupSizePixels);\n      } else {\n        return sizes;\n      }\n    },\n    setLayout: (sizes, unitsFromParams) => {\n      const {\n        id: groupId,\n        panels,\n        sizes: prevSizes,\n        units\n      } = committedValuesRef.current;\n      if ((unitsFromParams || units) === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        sizes = sizes.map(size => size / groupSizePixels * 100);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const nextSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: sizes,\n        prevSizes,\n        units\n      });\n      if (!areEqual(prevSizes, nextSizes)) {\n        setSizes(nextSizes);\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n    }\n  }), [groupId]);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n    committedValuesRef.current.units = units;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const {\n      onLayout\n    } = callbacksRef.current;\n    const {\n      panels,\n      sizes\n    } = committedValuesRef.current;\n\n    // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n    if (sizes.length > 0) {\n      if (onLayout) {\n        onLayout(sizes);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // When possible, we notify before the next render so that rendering work can be batched together.\n      // Some cases are difficult to detect though,\n      // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n      // In this case, the best we can do is notify on commit.\n      // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const {\n      id: groupId,\n      sizes,\n      units\n    } = committedValuesRef.current;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes = null;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray, storage);\n    }\n    if (defaultSizes != null) {\n      // Validate saved sizes in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const validatedSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: defaultSizes,\n        prevSizes: defaultSizes,\n        units\n      });\n      setSizes(validatedSizes);\n    } else {\n      const sizes = calculateDefaultLayout({\n        groupId,\n        panels,\n        units\n      });\n      setSizes(sizes);\n    }\n  }, [autoSaveId, panels, storage]);\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n    {\n      const {\n        didLogIdAndOrderWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const {\n          panels\n        } = committedValuesRef.current;\n        const panelIds = Array.from(panels.keys());\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (Array.from(panels.values()).find(panel => panel.current.idWasAutoGenerated || panel.current.order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n  useIsomorphicLayoutEffect(() => {\n    // Pixel panel constraints need to be reassessed after a group resize\n    // We can avoid the ResizeObserver overhead for relative layouts\n    if (units === \"pixels\") {\n      const resizeObserver = new ResizeObserver(() => {\n        const {\n          panels,\n          sizes: prevSizes\n        } = committedValuesRef.current;\n        const nextSizes = validatePanelGroupLayout({\n          groupId,\n          panels,\n          nextSizes: prevSizes,\n          prevSizes,\n          units\n        });\n        if (!areEqual(prevSizes, nextSizes)) {\n          setSizes(nextSizes);\n        }\n      });\n      resizeObserver.observe(getPanelGroup(groupId));\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId, units]);\n  const getPanelSize = useCallback((id, unitsFromParams) => {\n    const {\n      panels,\n      units: unitsFromProps\n    } = committedValuesRef.current;\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.findIndex(panel => panel.current.id === id);\n    const size = sizes[index];\n    const units = unitsFromParams ?? unitsFromProps;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      return size / 100 * groupSizePixels;\n    } else {\n      return size;\n    }\n  }, [groupId, sizes]);\n  const getPanelStyle = useCallback((id, defaultSize) => {\n    const {\n      panels\n    } = committedValuesRef.current;\n\n    // Before mounting, Panels will not yet have registered themselves.\n    // This includes server rendering.\n    // At this point the best we can do is render everything with the same size.\n    if (panels.size === 0) {\n      {\n        if (!devWarningsRef.current.didLogDefaultSizeWarning) ;\n      }\n      return {\n        flexBasis: 0,\n        flexGrow: defaultSize != null ? defaultSize : undefined,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\"\n      };\n    }\n    const flexGrow = getFlexGrow(panels, id, sizes);\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      // Without this, Panel sizes may be unintentionally overridden by their content.\n      overflow: \"hidden\",\n      // Disable pointer events inside of a panel during resize.\n      // This avoid edge cases like nested iframes.\n      pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n    };\n  }, [activeHandleId, disablePointerEventsDuringResize, sizes]);\n  const registerPanel = useCallback((id, panelRef) => {\n    const {\n      units\n    } = committedValuesRef.current;\n    validatePanelProps(units, panelRef);\n    setPanels(prevPanels => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n      return nextPanels;\n    });\n  }, []);\n  const registerResizeHandle = useCallback(handleId => {\n    const resizeHandler = event => {\n      event.preventDefault();\n      const {\n        direction,\n        panels,\n        sizes: prevSizes\n      } = committedValuesRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n      let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n      if (movement === 0) {\n        return;\n      }\n      const groupElement = getPanelGroup(groupId);\n      const rect = groupElement.getBoundingClientRect();\n      const isHorizontal = direction === \"horizontal\";\n\n      // Support RTL layouts\n      if (document.dir === \"rtl\" && isHorizontal) {\n        movement = -movement;\n      }\n      const size = isHorizontal ? rect.width : rect.height;\n      const delta = movement / size * 100;\n\n      // If a validateLayout method has been provided\n      // it's important to use it before updating the mouse cursor\n      const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n      const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n      // Don't update cursor for resizes triggered by keyboard interactions.\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          if (!sizesChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (sizesChanged) {\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // It's okay to bypass in this case because we already validated above\n        setSizes(nextSizes);\n\n        // If resize change handlers have been declared, this is the time to call them.\n        // Trigger user callbacks after updating state, so that user code can override the sizes.\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n      prevDeltaRef.current = delta;\n    };\n    return resizeHandler;\n  }, [groupId]);\n  const unregisterPanel = useCallback(id => {\n    setPanels(prevPanels => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n      return nextPanels;\n    });\n  }, []);\n  const collapsePanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      collapsible\n    } = panel.current;\n    if (!collapsible) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === collapsedSize) {\n      // Panel is already collapsed.\n      return;\n    }\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const expandPanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      minSize\n    } = panel.current;\n    const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize !== collapsedSize) {\n      // Panel is already expanded.\n      return;\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? collapsedSize - sizeBeforeCollapse : sizeBeforeCollapse;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const resizePanel = useCallback((id, nextSize, unitsFromParams) => {\n    const {\n      id: groupId,\n      panels,\n      sizes: prevSizes,\n      units\n    } = committedValuesRef.current;\n    if ((unitsFromParams || units) === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      nextSize = nextSize / groupSizePixels * 100;\n    }\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    let {\n      collapsedSize,\n      collapsible,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n    if (collapsible && nextSize === collapsedSize) ; else {\n      const unsafeNextSize = nextSize;\n      nextSize = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n      {\n        if (unsafeNextSize !== nextSize) {\n          console.error(`Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n        }\n      }\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const context = useMemo(() => ({\n    activeHandleId,\n    collapsePanel,\n    direction,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging: (id, event) => {\n      setActiveHandleId(id);\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        const handleElement = getResizeHandle(id);\n        initialDragStateRef.current = {\n          dragHandleRect: handleElement.getBoundingClientRect(),\n          dragOffset: getDragOffset(event, id, direction),\n          sizes: committedValuesRef.current.sizes\n        };\n      }\n    },\n    stopDragging: () => {\n      resetGlobalCursorStyle();\n      setActiveHandleId(null);\n      initialDragStateRef.current = null;\n    },\n    units,\n    unregisterPanel\n  }), [activeHandleId, collapsePanel, direction, expandPanel, getPanelSize, getPanelStyle, groupId, registerPanel, registerResizeHandle, resizePanel, units, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      \"data-panel-group-units\": units,\n      style: {\n        ...style,\n        ...styleFromProps\n      }\n    }),\n    value: context\n  });\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nexport { Panel, PanelGroup, PanelResizeHandle, getAvailableGroupSizePixels };\n"],
  "mappings": ";;;;;;;;AAAA,YAAuB;AAMvB,IAAM;AAAA,EACJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,IAAI;AAGJ,IAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC;AAEtC,IAAM,4BAA4B;AAElC,IAAM,eAAe,OAAO,UAAU,aAAa,QAAQ,MAAM;AACjE,IAAI,UAAU;AACd,SAAS,YAAY,eAAe,MAAM;AACxC,QAAM,cAAc,aAAa;AACjC,QAAM,QAAQ,OAAO,gBAAgB,eAAe,IAAI;AACxD,MAAI,MAAM,YAAY,MAAM;AAC1B,UAAM,UAAU,KAAK;AAAA,EACvB;AACA,SAAO,MAAM;AACf;AAEA,IAAM,oBAAoB,cAAc,IAAI;AAC5C,kBAAkB,cAAc;AAEhC,SAAS,sBAAsB;AAAA,EAC7B,WAAW;AAAA,EACX,WAAW,qBAAqB;AAAA,EAChC,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,cAAc;AAAA,EACd;AAAA,EACA,IAAI,cAAc;AAAA,EAClB,UAAU;AAAA,EACV;AAAA,EACA,aAAa;AAAA,EACb,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,OAAO,iBAAiB,CAAC;AAAA,EACzB,SAAS,OAAO;AAClB,GAAG;AACD,QAAM,UAAU,WAAW,iBAAiB;AAC5C,MAAI,YAAY,MAAM;AACpB,UAAM,MAAM,iEAAiE;AAAA,EAC/E;AACA,QAAM,UAAU,YAAY,WAAW;AACvC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,MAAI,WAAW,MAAM;AACnB,QAAI,UAAU,eAAe;AAE3B,gBAAU;AAAA,IACZ,OAAO;AAEL,gBAAU;AAAA,IACZ;AAAA,EACF;AAGA,QAAM,eAAe,OAAO;AAAA,IAC1B;AAAA,IACA;AAAA,EACF,CAAC;AACD,YAAU,MAAM;AACd,iBAAa,QAAQ,aAAa;AAClC,iBAAa,QAAQ,WAAW;AAAA,EAClC,CAAC;AACD,QAAM,QAAQ,cAAc,SAAS,WAAW;AAChD,QAAM,qBAAqB,OAAO;AAAA,IAChC,MAAM,mBAAmB,KAAK;AAAA,EAChC,CAAC;AACD,QAAM,eAAe,OAAO;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,IAAI;AAAA,IACJ,oBAAoB,eAAe;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,4BAA0B,MAAM;AAC9B,uBAAmB,QAAQ,OAAO,mBAAmB,KAAK;AAC1D,iBAAa,QAAQ,eAAe;AACpC,iBAAa,QAAQ,gBAAgB;AACrC,iBAAa,QAAQ,cAAc;AACnC,iBAAa,QAAQ,cAAc;AACnC,iBAAa,QAAQ,KAAK;AAC1B,iBAAa,QAAQ,qBAAqB,eAAe;AACzD,iBAAa,QAAQ,UAAU;AAC/B,iBAAa,QAAQ,UAAU;AAC/B,iBAAa,QAAQ,QAAQ;AAAA,EAC/B,CAAC;AACD,4BAA0B,MAAM;AAC9B,kBAAc,SAAS,YAAY;AACnC,WAAO,MAAM;AACX,sBAAgB,OAAO;AAAA,IACzB;AAAA,EACF,GAAG,CAAC,OAAO,SAAS,eAAe,eAAe,CAAC;AACnD,sBAAoB,cAAc,OAAO;AAAA,IACvC,UAAU,MAAM,cAAc,OAAO;AAAA,IACrC,QAAQ,MAAM,YAAY,OAAO;AAAA,IACjC,eAAe;AACb,aAAO,mBAAmB,QAAQ,SAAS;AAAA,IAC7C;AAAA,IACA,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,IACA,QAAQA,QAAO;AACb,aAAO,aAAa,SAASA,MAAK;AAAA,IACpC;AAAA,IACA,QAAQ,CAAC,YAAYA,WAAU,YAAY,SAAS,YAAYA,MAAK;AAAA,EACvE,IAAI,CAAC,eAAe,aAAa,cAAc,SAAS,WAAW,CAAC;AACpE,SAAO,cAAc,MAAM;AAAA,IACzB;AAAA,IACA,WAAW;AAAA,IACX,cAAc;AAAA,IACd,0BAA0B,eAAe;AAAA,IACzC,iBAAiB;AAAA,IACjB,mBAAmB,WAAW,KAAK,MAAM,QAAQ,EAAE,QAAQ,CAAC;AAAA,IAC5D,IAAI,iBAAiB,OAAO;AAAA,IAC5B,OAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACF,CAAC;AACH;AACA,IAAM,QAAQ,WAAW,CAAC,OAAO,QAAQ,cAAc,uBAAuB;AAAA,EAC5E,GAAG;AAAA,EACH,cAAc;AAChB,CAAC,CAAC;AACF,sBAAsB,cAAc;AACpC,MAAM,cAAc;AAGpB,SAAS,mBAAmB,OAAO;AACjC,QAAM;AAAA,IACJ;AAAA,EACF,IAAI;AACJ,MAAI,OAAO,aAAa,UAAU;AAChC,WAAO,WAAW,QAAQ;AAAA,EAC5B,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,IAAM,YAAY;AAElB,SAAS,cAAc,OAAO,iBAAiB,UAAU,SAAS,aAAa,WAAW,yBAAyB,kBAAkB;AACnI,QAAM;AAAA,IACJ,IAAI;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,kBAAkB,UAAU,WAAW,4BAA4B,OAAO,IAAI;AACpF,QAAM;AAAA,IACJ,OAAO;AAAA,EACT,IAAI,oBAAoB,CAAC;AAIzB,QAAM,YAAY,gBAAgB;AAClC,QAAM,cAAc,uBAAuB,MAAM;AACjD,QAAM,YAAY,UAAU,OAAO;AACnC,MAAI,eAAe;AAWnB;AACE,UAAMC,WAAU,cAAc,IAAI,UAAU;AAC5C,UAAMC,SAAQ,YAAY,UAAU,CAAAC,WAASA,OAAM,QAAQ,OAAOF,QAAO;AACzE,UAAM,QAAQ,YAAYC,MAAK;AAC/B,UAAM,WAAW,UAAUA,MAAK;AAChC,UAAM,WAAW,gBAAgB,OAAO,iBAAiB,OAAO,UAAU,WAAW,KAAK,IAAI,WAAW,GAAG,KAAK;AACjH,QAAI,aAAa,UAAU;AAEzB,aAAO;AAAA,IACT,OAAO;AACL,UAAI,aAAa,KAAK,WAAW,GAAG;AAClC,gCAAwB,IAAID,UAAS,QAAQ;AAAA,MAC/C;AACA,oBAAc,cAAc,IAAI,WAAW,WAAW,WAAW;AAAA,IACnE;AAAA,EACF;AACA,MAAI,UAAU,cAAc,IAAI,WAAW;AAC3C,MAAI,QAAQ,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,OAAO;AACvE,SAAO,MAAM;AACX,UAAM,QAAQ,YAAY,KAAK;AAC/B,UAAM,WAAW,UAAU,KAAK;AAChC,UAAM,iBAAiB,KAAK,IAAI,WAAW,IAAI,KAAK,IAAI,YAAY;AACpE,UAAM,WAAW,gBAAgB,OAAO,iBAAiB,OAAO,UAAU,WAAW,gBAAgB,KAAK;AAC1G,QAAI,aAAa,UAAU;AACzB,UAAI,aAAa,KAAK,WAAW,GAAG;AAClC,gCAAwB,IAAI,MAAM,QAAQ,IAAI,QAAQ;AAAA,MACxD;AACA,sBAAgB,WAAW;AAC3B,gBAAU,KAAK,IAAI;AACnB,UAAI,aAAa,YAAY,SAAS,EAAE,cAAc,KAAK,IAAI,WAAW,EAAE,YAAY,SAAS,GAAG,QAAW;AAAA,QAC7G,SAAS;AAAA,MACX,CAAC,KAAK,GAAG;AACP;AAAA,MACF;AAAA,IACF;AACA,QAAI,cAAc,GAAG;AACnB,UAAI,EAAE,QAAQ,GAAG;AACf;AAAA,MACF;AAAA,IACF,OAAO;AACL,UAAI,EAAE,SAAS,YAAY,QAAQ;AACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAIA,MAAI,iBAAiB,GAAG;AACtB,WAAO;AAAA,EACT;AAGA,YAAU,cAAc,IAAI,UAAU;AACtC,UAAQ,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,OAAO;AACnE,YAAU,KAAK,IAAI,UAAU,KAAK,IAAI;AACtC,SAAO;AACT;AACA,SAAS,mBAAmB,aAAa,OAAO,8BAA8B;AAC5E,QAAM,QAAQ,CAAC,MAAM,UAAU;AAC7B,UAAM,WAAW,YAAY,KAAK;AAClC,QAAI,CAAC,UAAU;AAGb;AAAA,IACF;AACA,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,SAAS;AACb,UAAM,mBAAmB,6BAA6B,EAAE;AACxD,QAAI,qBAAqB,MAAM;AAC7B,mCAA6B,EAAE,IAAI;AACnC,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,MACF,IAAI,aAAa;AACjB,UAAI,UAAU;AACZ,iBAAS,MAAM,gBAAgB;AAAA,MACjC;AACA,UAAI,eAAe,YAAY;AAC7B,aAAK,oBAAoB,QAAQ,qBAAqB,kBAAkB,SAAS,eAAe;AAC9F,qBAAW,KAAK;AAAA,QAClB,WAAW,qBAAqB,iBAAiB,SAAS,eAAe;AACvE,qBAAW,IAAI;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AACA,SAAS,uBAAuB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,QAAM,kBAAkB,UAAU,WAAW,4BAA4B,OAAO,IAAI;AACpF,QAAM,cAAc,uBAAuB,MAAM;AACjD,QAAM,QAAQ,MAAM,YAAY,MAAM;AACtC,MAAI,qBAAqB;AACzB,MAAI,gBAAgB;AAIpB,WAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACvD,UAAM,QAAQ,YAAY,KAAK;AAC/B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,MAAM;AACV,QAAI,eAAe,MAAM;AACvB;AACA,YAAM,KAAK,IAAI,UAAU,WAAW,cAAc,kBAAkB,MAAM;AAC1E,uBAAiB,MAAM,KAAK;AAAA,IAC9B;AAAA,EACF;AAIA,WAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACvD,UAAM,QAAQ,YAAY,KAAK;AAC/B,QAAI;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,MAAM;AACV,QAAI,eAAe,MAAM;AACvB;AAAA,IACF;AACA,QAAI,UAAU,UAAU;AACtB,gBAAU,UAAU,kBAAkB;AACtC,UAAI,WAAW,MAAM;AACnB,kBAAU,UAAU,kBAAkB;AAAA,MACxC;AAAA,IACF;AACA,UAAM,kBAAkB,YAAY,SAAS;AAC7C,UAAM,OAAO,KAAK,IAAI,WAAW,OAAO,UAAU,KAAK,KAAK,IAAI,SAAS,gBAAgB,eAAe,CAAC;AACzG,UAAM,KAAK,IAAI;AACf;AACA,qBAAiB;AAAA,EACnB;AAIA,MAAI,kBAAkB,GAAG;AACvB,aAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACvD,YAAM,QAAQ,YAAY,KAAK;AAC/B,UAAI;AAAA,QACF;AAAA,QACA;AAAA,MACF,IAAI,MAAM;AACV,UAAI,UAAU,UAAU;AACtB,kBAAU,UAAU,kBAAkB;AACtC,YAAI,WAAW,MAAM;AACnB,oBAAU,UAAU,kBAAkB;AAAA,QACxC;AAAA,MACF;AACA,YAAM,OAAO,KAAK,IAAI,WAAW,OAAO,UAAU,KAAK,KAAK,IAAI,SAAS,MAAM,KAAK,IAAI,aAAa,CAAC;AACtG,UAAI,SAAS,MAAM,KAAK,GAAG;AACzB,yBAAiB,OAAO,MAAM,KAAK;AACnC,cAAM,KAAK,IAAI;AAGf,YAAI,KAAK,IAAI,aAAa,EAAE,QAAQ,CAAC,MAAM,SAAS;AAClD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,MAAI,KAAK,IAAI,aAAa,EAAE,QAAQ,CAAC,MAAM,SAAS;AAClD;AACE,cAAQ,MAAM,qFAAqF,MAAM,eAAe,QAAQ,CAAC,CAAC,mEAAmE;AAAA,IACvM;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,qBAAqB,IAAI,aAAa;AAC7C,MAAI,YAAY,SAAS,GAAG;AAC1B,WAAO,CAAC,MAAM,IAAI;AAAA,EACpB;AACA,QAAM,QAAQ,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,EAAE;AACpE,MAAI,QAAQ,GAAG;AACb,WAAO,CAAC,MAAM,IAAI;AAAA,EACpB;AACA,QAAM,cAAc,UAAU,YAAY,SAAS;AACnD,QAAM,WAAW,cAAc,YAAY,QAAQ,CAAC,EAAE,QAAQ,KAAK;AACnE,QAAM,UAAU,cAAc,KAAK,YAAY,QAAQ,CAAC,EAAE,QAAQ;AAClE,SAAO,CAAC,UAAU,OAAO;AAC3B;AACA,SAAS,4BAA4B,SAAS;AAC5C,QAAM,oBAAoB,cAAc,OAAO;AAC/C,MAAI,qBAAqB,MAAM;AAC7B,WAAO;AAAA,EACT;AACA,QAAM,YAAY,kBAAkB,aAAa,4BAA4B;AAC7E,QAAM,gBAAgB,yBAAyB,OAAO;AACtD,MAAI,cAAc,cAAc;AAC9B,WAAO,kBAAkB,cAAc,cAAc,OAAO,CAAC,aAAa,WAAW;AACnF,aAAO,cAAc,OAAO;AAAA,IAC9B,GAAG,CAAC;AAAA,EACN,OAAO;AACL,WAAO,kBAAkB,eAAe,cAAc,OAAO,CAAC,aAAa,WAAW;AACpF,aAAO,cAAc,OAAO;AAAA,IAC9B,GAAG,CAAC;AAAA,EACN;AACF;AAIA,SAAS,YAAY,QAAQ,IAAI,OAAO;AACtC,MAAI,OAAO,SAAS,GAAG;AACrB,WAAO;AAAA,EACT;AACA,QAAM,cAAc,uBAAuB,MAAM;AACjD,QAAM,QAAQ,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,EAAE;AACpE,QAAM,OAAO,MAAM,KAAK;AACxB,MAAI,QAAQ,MAAM;AAChB,WAAO;AAAA,EACT;AACA,SAAO,KAAK,YAAY,SAAS;AACnC;AACA,SAAS,SAAS,IAAI;AACpB,QAAMG,WAAU,SAAS,cAAc,mBAAmB,EAAE,IAAI;AAChE,MAAIA,UAAS;AACX,WAAOA;AAAA,EACT;AACA,SAAO;AACT;AACA,SAAS,cAAc,IAAI;AACzB,QAAMA,WAAU,SAAS,cAAc,yBAAyB,EAAE,IAAI;AACtE,MAAIA,UAAS;AACX,WAAOA;AAAA,EACT;AACA,SAAO;AACT;AACA,SAAS,gBAAgB,IAAI;AAC3B,QAAMA,WAAU,SAAS,cAAc,iCAAiC,EAAE,IAAI;AAC9E,MAAIA,UAAS;AACX,WAAOA;AAAA,EACT;AACA,SAAO;AACT;AACA,SAAS,qBAAqB,IAAI;AAChC,QAAM,UAAU,iBAAiB;AACjC,QAAM,QAAQ,QAAQ,UAAU,YAAU,OAAO,aAAa,6BAA6B,MAAM,EAAE;AACnG,SAAO,SAAS;AAClB;AACA,SAAS,mBAAmB;AAC1B,SAAO,MAAM,KAAK,SAAS,iBAAiB,+BAA+B,CAAC;AAC9E;AACA,SAAS,yBAAyB,SAAS;AACzC,SAAO,MAAM,KAAK,SAAS,iBAAiB,sDAAsD,OAAO,IAAI,CAAC;AAChH;AACA,SAAS,wBAAwB,SAAS,UAAU,aAAa;AAtcjE;AAucE,QAAM,SAAS,gBAAgB,QAAQ;AACvC,QAAM,UAAU,yBAAyB,OAAO;AAChD,QAAM,QAAQ,SAAS,QAAQ,QAAQ,MAAM,IAAI;AACjD,QAAM,aAAW,uBAAY,KAAK,MAAjB,mBAAoB,YAApB,mBAA6B,OAAM;AACpD,QAAM,YAAU,uBAAY,QAAQ,CAAC,MAArB,mBAAwB,YAAxB,mBAAiC,OAAM;AACvD,SAAO,CAAC,UAAU,OAAO;AAC3B;AACA,SAAS,uBAAuB,QAAQ;AACtC,SAAO,MAAM,KAAK,OAAO,OAAO,CAAC,EAAE,KAAK,CAAC,QAAQ,WAAW;AAC1D,UAAM,SAAS,OAAO,QAAQ;AAC9B,UAAM,SAAS,OAAO,QAAQ;AAC9B,QAAI,UAAU,QAAQ,UAAU,MAAM;AACpC,aAAO;AAAA,IACT,WAAW,UAAU,MAAM;AACzB,aAAO;AAAA,IACT,WAAW,UAAU,MAAM;AACzB,aAAO;AAAA,IACT,OAAO;AACL,aAAO,SAAS;AAAA,IAClB;AAAA,EACF,CAAC;AACH;AACA,SAAS,gBAAgB,OAAO,iBAAiB,OAAO,UAAU,UAAU,QAAQ,MAAM;AA7d1F;AA8dE,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,MAAM;AACV,MAAI,UAAU,UAAU;AACtB,oBAAgB,gBAAgB,kBAAkB;AAClD,QAAI,WAAW,MAAM;AACnB,gBAAU,UAAU,kBAAkB;AAAA,IACxC;AACA,cAAU,UAAU,kBAAkB;AAAA,EACxC;AACA,MAAI,aAAa;AACf,QAAI,WAAW,eAAe;AAE5B,UAAI,YAAY,UAAU,IAAI,eAAe;AAC3C,eAAO;AAAA,MACT;AAAA,IACF,OAAO;AACL,YAAM,mBAAkB,oCAAO,SAAP,mBAAa,WAAW;AAChD,UAAI,CAAC,iBAAiB;AAIpB,YAAI,WAAW,SAAS;AACtB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO,KAAK,IAAI,WAAW,OAAO,UAAU,KAAK,KAAK,IAAI,SAAS,QAAQ,CAAC;AAC9E;AACA,SAAS,mBAAmB,OAAO,WAAW;AAC5C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,UAAU;AAGd,MAAI,UAAU,KAAK,UAAU,iBAAiB,UAAU,KAAK;AAC3D;AACE,cAAQ,MAAM,mCAAmC,OAAO,EAAE;AAAA,IAC5D;AACA,cAAU,QAAQ,UAAU;AAAA,EAC9B;AACA,MAAI,WAAW,MAAM;AACnB,QAAI,UAAU,KAAK,UAAU,iBAAiB,UAAU,KAAK;AAC3D;AACE,gBAAQ,MAAM,mCAAmC,OAAO,EAAE;AAAA,MAC5D;AACA,gBAAU,QAAQ,UAAU;AAAA,IAC9B;AAAA,EACF;AACA,MAAI,gBAAgB,MAAM;AACxB,QAAI,cAAc,KAAK,UAAU,iBAAiB,cAAc,KAAK;AACnE;AACE,gBAAQ,MAAM,uCAAuC,WAAW,EAAE;AAAA,MACpE;AACA,gBAAU,QAAQ,cAAc;AAAA,IAClC,WAAW,cAAc,WAAW,CAAC,aAAa;AAChD;AACE,gBAAQ,MAAM,kBAAkB,OAAO,yCAAyC,WAAW,GAAG;AAAA,MAChG;AACA,gBAAU,QAAQ,cAAc;AAAA,IAClC,WAAW,WAAW,QAAQ,cAAc,SAAS;AACnD;AACE,gBAAQ,MAAM,kBAAkB,OAAO,sCAAsC,WAAW,GAAG;AAAA,MAC7F;AACA,gBAAU,QAAQ,cAAc;AAAA,IAClC;AAAA,EACF;AACF;AACA,SAAS,yBAAyB;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAG;AAED,cAAY,CAAC,GAAG,SAAS;AACzB,QAAM,cAAc,uBAAuB,MAAM;AACjD,QAAM,kBAAkB,UAAU,WAAW,4BAA4B,OAAO,IAAI;AACpF,MAAI,gBAAgB;AAGpB,WAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACvD,UAAM,QAAQ,YAAY,KAAK;AAC/B,UAAM,WAAW,UAAU,KAAK;AAChC,UAAM,WAAW,UAAU,KAAK;AAChC,UAAM,eAAe,gBAAgB,OAAO,iBAAiB,OAAO,UAAU,QAAQ;AACtF,QAAI,YAAY,cAAc;AAC5B,uBAAiB,WAAW;AAC5B,gBAAU,KAAK,IAAI;AACnB;AACE,gBAAQ,MAAM,iBAAiB,QAAQ,0BAA0B,MAAM,QAAQ,EAAE,8CAA8C;AAAA,MACjI;AAAA,IACF;AAAA,EACF;AAIA,MAAI,cAAc,QAAQ,CAAC,MAAM,SAAS;AACxC,aAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACvD,YAAM,QAAQ,YAAY,KAAK;AAC/B,UAAI;AAAA,QACF;AAAA,QACA;AAAA,MACF,IAAI,MAAM;AACV,UAAI,UAAU,UAAU;AACtB,kBAAU,UAAU,kBAAkB;AACtC,YAAI,WAAW,MAAM;AACnB,oBAAU,UAAU,kBAAkB;AAAA,QACxC;AAAA,MACF;AACA,YAAM,OAAO,KAAK,IAAI,WAAW,OAAO,UAAU,KAAK,KAAK,IAAI,SAAS,UAAU,KAAK,IAAI,aAAa,CAAC;AAC1G,UAAI,SAAS,UAAU,KAAK,GAAG;AAC7B,yBAAiB,OAAO,UAAU,KAAK;AACvC,kBAAU,KAAK,IAAI;AAGnB,YAAI,KAAK,IAAI,aAAa,EAAE,QAAQ,CAAC,MAAM,SAAS;AAClD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,MAAI,cAAc,QAAQ,CAAC,MAAM,SAAS;AACxC;AACE,cAAQ,MAAM,qFAAqF,MAAM,aAAa,GAAG;AAAA,IAC3H;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,OAAO,mBAAmB,UAAU,qBAAqB;AAChE,MAAI,CAAC,mBAAmB;AACtB,YAAQ,MAAM,OAAO;AACrB,UAAM,MAAM,OAAO;AAAA,EACrB;AACF;AAIA,SAAS,oCAAoC;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,YAAU,MAAM;AACd,UAAM;AAAA,MACJ;AAAA,MACA,QAAAC;AAAA,IACF,IAAI,mBAAmB;AACvB,UAAM,eAAe,cAAc,OAAO;AAC1C,WAAO,gBAAgB,MAAM,0BAA0B,OAAO,GAAG;AACjE,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,aAAa,sBAAsB;AACvC,UAAM,UAAU,yBAAyB,OAAO;AAChD,UAAM,mBAAmB,QAAQ,IAAI,YAAU;AAC7C,YAAM,WAAW,OAAO,aAAa,6BAA6B;AAClE,YAAM,cAAc,uBAAuBA,OAAM;AACjD,YAAM,CAAC,UAAU,OAAO,IAAI,wBAAwB,SAAS,UAAU,WAAW;AAClF,UAAI,YAAY,QAAQ,WAAW,MAAM;AACvC,eAAO,MAAM;AAAA,QAAC;AAAA,MAChB;AACA,UAAI,iBAAiB;AACrB,UAAI,iBAAiB;AACrB,UAAI,eAAe;AACnB,UAAI,eAAe;AAGnB,kBAAY,QAAQ,eAAa;AAC/B,cAAM;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,QACF,IAAI,UAAU;AACd,YAAI,OAAO,UAAU;AACnB,2BAAiB;AACjB,2BAAiB,WAAW,OAAO,UAAU;AAAA,QAC/C,OAAO;AACL,0BAAgB;AAChB,0BAAgB,WAAW,OAAO,UAAU;AAAA,QAC9C;AAAA,MACF,CAAC;AACD,YAAM,eAAe,KAAK,IAAI,gBAAgB,MAAM,YAAY;AAChE,YAAM,eAAe,KAAK,IAAI,iBAAiB,YAAY,SAAS,KAAK,MAAM,YAAY;AAC3F,YAAM,WAAW,YAAYA,SAAQ,UAAU,KAAK;AACpD,aAAO,aAAa,iBAAiB,KAAK,KAAK,MAAM,YAAY,CAAC;AAClE,aAAO,aAAa,iBAAiB,KAAK,KAAK,MAAM,YAAY,CAAC;AAClE,aAAO,aAAa,iBAAiB,KAAK,KAAK,MAAM,SAAS,QAAQ,CAAC,CAAC;AACxE,YAAM,YAAY,WAAS;AACzB,YAAI,MAAM,kBAAkB;AAC1B;AAAA,QACF;AACA,gBAAQ,MAAM,KAAK;AAAA,UACjB,KAAK,SACH;AACE,kBAAM,eAAe;AACrB,kBAAM,QAAQ,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,QAAQ;AAC1E,gBAAI,SAAS,GAAG;AACd,oBAAM,YAAY,YAAY,KAAK;AACnC,oBAAM,OAAO,MAAM,KAAK;AACxB,kBAAI,QAAQ,MAAM;AAChB,oBAAI,QAAQ;AACZ,oBAAI,KAAK,YAAY,SAAS,KAAK,UAAU,QAAQ,QAAQ,YAAY,SAAS,GAAG;AACnF,0BAAQ,cAAc,eAAe,QAAQ;AAAA,gBAC/C,OAAO;AACL,0BAAQ,EAAE,cAAc,eAAe,QAAQ;AAAA,gBACjD;AACA,sBAAM,YAAY,cAAc,OAAO,mBAAmB,SAAS,UAAU,SAAS,OAAO,OAAO,wBAAwB,SAAS,IAAI;AACzI,oBAAI,UAAU,WAAW;AACvB,2BAAS,SAAS;AAAA,gBACpB;AAAA,cACF;AAAA,YACF;AACA;AAAA,UACF;AAAA,QACJ;AAAA,MACF;AACA,aAAO,iBAAiB,WAAW,SAAS;AAC5C,YAAM,cAAc,SAAS,QAAQ;AACrC,UAAI,eAAe,MAAM;AACvB,eAAO,aAAa,iBAAiB,YAAY,EAAE;AAAA,MACrD;AACA,aAAO,MAAM;AACX,eAAO,gBAAgB,eAAe;AACtC,eAAO,gBAAgB,eAAe;AACtC,eAAO,gBAAgB,eAAe;AACtC,eAAO,oBAAoB,WAAW,SAAS;AAC/C,YAAI,eAAe,MAAM;AACvB,iBAAO,gBAAgB,eAAe;AAAA,QACxC;AAAA,MACF;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AACX,uBAAiB,QAAQ,qBAAmB,gBAAgB,CAAC;AAAA,IAC/D;AAAA,EACF,GAAG,CAAC,oBAAoB,SAAS,QAAQ,yBAAyB,UAAU,KAAK,CAAC;AACpF;AACA,SAAS,uCAAuC;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,YAAU,MAAM;AACd,QAAI,YAAY,iBAAiB,MAAM;AACrC;AAAA,IACF;AACA,UAAM,gBAAgB,gBAAgB,QAAQ;AAC9C,QAAI,iBAAiB,MAAM;AACzB;AAAA,IACF;AACA,UAAM,YAAY,WAAS;AACzB,UAAI,MAAM,kBAAkB;AAC1B;AAAA,MACF;AACA,cAAQ,MAAM,KAAK;AAAA,QACjB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK,QACH;AACE,gBAAM,eAAe;AACrB,wBAAc,KAAK;AACnB;AAAA,QACF;AAAA,QACF,KAAK,MACH;AACE,gBAAM,eAAe;AACrB,gBAAM,UAAU,iBAAiB;AACjC,gBAAM,QAAQ,qBAAqB,QAAQ;AAC3C,iBAAO,UAAU,IAAI;AACrB,gBAAM,YAAY,MAAM,WAAW,QAAQ,IAAI,QAAQ,IAAI,QAAQ,SAAS,IAAI,QAAQ,IAAI,QAAQ,SAAS,QAAQ,IAAI;AACzH,gBAAM,aAAa,QAAQ,SAAS;AACpC,qBAAW,MAAM;AACjB;AAAA,QACF;AAAA,MACJ;AAAA,IACF;AACA,kBAAc,iBAAiB,WAAW,SAAS;AACnD,WAAO,MAAM;AACX,oBAAc,oBAAoB,WAAW,SAAS;AAAA,IACxD;AAAA,EACF,GAAG,CAAC,UAAU,UAAU,aAAa,CAAC;AACxC;AAEA,SAAS,SAAS,QAAQ,QAAQ;AAChC,MAAI,OAAO,WAAW,OAAO,QAAQ;AACnC,WAAO;AAAA,EACT;AACA,WAAS,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;AAClD,QAAI,OAAO,KAAK,MAAM,OAAO,KAAK,GAAG;AACnC,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,cAAc,OAAO,UAAU,WAAW,gBAAgB,GAAG,2BAA2B,MAAM;AACrG,QAAM,eAAe,cAAc;AACnC,MAAI,gBAAgB;AACpB,MAAI,aAAa,KAAK,GAAG;AACvB,oBAAgB,eAAe,MAAM,UAAU,MAAM;AAAA,EACvD,WAAW,aAAa,KAAK,GAAG;AAC9B,UAAM,aAAa,MAAM,QAAQ,CAAC;AAClC,oBAAgB,eAAe,WAAW,UAAU,WAAW;AAAA,EACjE,OAAO;AACL,WAAO;AAAA,EACT;AACA,QAAM,gBAAgB,gBAAgB,QAAQ;AAC9C,QAAM,OAAO,4BAA4B,cAAc,sBAAsB;AAC7E,QAAM,gBAAgB,eAAe,KAAK,OAAO,KAAK;AACtD,SAAO,gBAAgB,gBAAgB;AACzC;AAGA,SAAS,YAAY,OAAO,SAAS,UAAU,aAAa,WAAW,WAAW,kBAAkB;AAClG,QAAM;AAAA,IACJ,aAAa;AAAA,IACb;AAAA,IACA,OAAO;AAAA,EACT,IAAI,oBAAoB,CAAC;AAIzB,QAAM,YAAY,gBAAgB;AAClC,MAAI,UAAU,KAAK,GAAG;AACpB,UAAM,eAAe,cAAc;AACnC,UAAM,eAAe,cAAc,OAAO;AAC1C,UAAM,OAAO,aAAa,sBAAsB;AAChD,UAAM,oBAAoB,eAAe,KAAK,QAAQ,KAAK;AAC3D,UAAM,cAAc,MAAM,WAAW,KAAK;AAC1C,UAAM,QAAQ,oBAAoB;AAClC,QAAI,WAAW;AACf,YAAQ,MAAM,KAAK;AAAA,MACjB,KAAK;AACH,mBAAW,eAAe,IAAI;AAC9B;AAAA,MACF,KAAK;AACH,mBAAW,eAAe,CAAC,QAAQ;AACnC;AAAA,MACF,KAAK;AACH,mBAAW,eAAe,QAAQ;AAClC;AAAA,MACF,KAAK;AACH,mBAAW,eAAe,IAAI,CAAC;AAC/B;AAAA,MACF,KAAK;AACH,mBAAW;AACX;AAAA,MACF,KAAK;AACH,mBAAW,CAAC;AACZ;AAAA,IACJ;AAMA,UAAM,CAAC,UAAU,OAAO,IAAI,wBAAwB,SAAS,UAAU,WAAW;AAClF,UAAM,gBAAgB,WAAW,IAAI,WAAW;AAChD,UAAM,mBAAmB,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,aAAa;AAC1F,UAAM,cAAc,YAAY,gBAAgB;AAChD,QAAI,YAAY,QAAQ,aAAa;AACnC,YAAM,WAAW,UAAU,gBAAgB;AAC3C,UAAI,aAAa,KAAK,SAAS,YAAY,SAAS,MAAM,YAAY,QAAQ,QAAQ,YAAY,SAAS,GAAG;AAC5G,mBAAW,WAAW,IAAI,CAAC,YAAY,QAAQ,UAAU,oBAAoB,YAAY,QAAQ,UAAU;AAAA,MAC7G;AAAA,IACF;AACA,WAAO;AAAA,EACT,OAAO;AACL,WAAO,cAAc,OAAO,UAAU,WAAW,YAAY,cAAc;AAAA,EAC7E;AACF;AACA,SAAS,UAAU,OAAO;AACxB,SAAO,MAAM,SAAS;AACxB;AACA,SAAS,aAAa,OAAO;AAC3B,SAAO,MAAM,KAAK,WAAW,OAAO;AACtC;AACA,SAAS,aAAa,OAAO;AAC3B,SAAO,MAAM,KAAK,WAAW,OAAO;AACtC;AAEA,IAAI,eAAe;AACnB,IAAI,UAAU;AACd,SAAS,eAAe,OAAO;AAC7B,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,EACX;AACF;AACA,SAAS,yBAAyB;AAChC,MAAI,YAAY,MAAM;AACpB,aAAS,KAAK,YAAY,OAAO;AACjC,mBAAe;AACf,cAAU;AAAA,EACZ;AACF;AACA,SAAS,qBAAqB,OAAO;AACnC,MAAI,iBAAiB,OAAO;AAC1B;AAAA,EACF;AACA,iBAAe;AACf,QAAM,QAAQ,eAAe,KAAK;AAClC,MAAI,YAAY,MAAM;AACpB,cAAU,SAAS,cAAc,OAAO;AACxC,aAAS,KAAK,YAAY,OAAO;AAAA,EACnC;AACA,UAAQ,YAAY,aAAa,KAAK;AACxC;AAEA,SAAS,SAAS,UAAU,aAAa,IAAI;AAC3C,MAAI,YAAY;AAChB,MAAI,WAAW,IAAI,SAAS;AAC1B,QAAI,cAAc,MAAM;AACtB,mBAAa,SAAS;AAAA,IACxB;AACA,gBAAY,WAAW,MAAM;AAC3B,eAAS,GAAG,IAAI;AAAA,IAClB,GAAG,UAAU;AAAA,EACf;AACA,SAAO;AACT;AAMA,SAAS,oBAAoB,QAAQ;AACnC,SAAO,OAAO,IAAI,WAAS;AACzB,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,MAAM;AACV,WAAO,QAAQ,GAAG,KAAK,IAAI,OAAO,KAAK,GAAG,OAAO;AAAA,EACnD,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,cAAc,CAAC,CAAC,EAAE,KAAK,GAAG;AAChD;AACA,SAAS,8BAA8B,YAAY,SAAS;AAC1D,MAAI;AACF,UAAM,aAAa,QAAQ,QAAQ,oBAAoB,UAAU,EAAE;AACnE,QAAI,YAAY;AACd,YAAM,SAAS,KAAK,MAAM,UAAU;AACpC,UAAI,OAAO,WAAW,YAAY,UAAU,MAAM;AAChD,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AAAA,EAAC;AACjB,SAAO;AACT;AACA,SAAS,gBAAgB,YAAY,QAAQ,SAAS;AACpD,QAAM,QAAQ,8BAA8B,YAAY,OAAO;AAC/D,MAAI,OAAO;AACT,UAAM,MAAM,oBAAoB,MAAM;AACtC,WAAO,MAAM,GAAG,KAAK;AAAA,EACvB;AACA,SAAO;AACT;AACA,SAAS,qBAAqB,YAAY,QAAQ,OAAO,SAAS;AAChE,QAAM,MAAM,oBAAoB,MAAM;AACtC,QAAM,QAAQ,8BAA8B,YAAY,OAAO,KAAK,CAAC;AACrE,QAAM,GAAG,IAAI;AACb,MAAI;AACF,YAAQ,QAAQ,oBAAoB,UAAU,IAAI,KAAK,UAAU,KAAK,CAAC;AAAA,EACzE,SAAS,OAAO;AACd,YAAQ,MAAM,KAAK;AAAA,EACrB;AACF;AAEA,IAAM,cAAc,CAAC;AAMrB,SAAS,yBAAyB,eAAe;AAC/C,MAAI;AACF,QAAI,OAAO,iBAAiB,aAAa;AAEvC,oBAAc,UAAU,UAAQ;AAC9B,eAAO,aAAa,QAAQ,IAAI;AAAA,MAClC;AACA,oBAAc,UAAU,CAAC,MAAM,UAAU;AACvC,qBAAa,QAAQ,MAAM,KAAK;AAAA,MAClC;AAAA,IACF,OAAO;AACL,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,MAAM,KAAK;AACnB,kBAAc,UAAU,MAAM;AAC9B,kBAAc,UAAU,MAAM;AAAA,IAAC;AAAA,EACjC;AACF;AACA,IAAM,iBAAiB;AAAA,EACrB,SAAS,UAAQ;AACf,6BAAyB,cAAc;AACvC,WAAO,eAAe,QAAQ,IAAI;AAAA,EACpC;AAAA,EACA,SAAS,CAAC,MAAM,UAAU;AACxB,6BAAyB,cAAc;AACvC,mBAAe,QAAQ,MAAM,KAAK;AAAA,EACpC;AACF;AASA,SAAS,2BAA2B;AAAA,EAClC;AAAA,EACA,WAAW;AAAA,EACX,WAAW,qBAAqB;AAAA,EAChC;AAAA,EACA,mCAAmC;AAAA,EACnC;AAAA,EACA,IAAI,cAAc;AAAA,EAClB;AAAA,EACA,UAAU;AAAA,EACV,OAAO,iBAAiB,CAAC;AAAA,EACzB,SAAS,OAAO;AAAA,EAChB,QAAQ;AACV,GAAG;AACD,QAAM,UAAU,YAAY,WAAW;AACvC,QAAM,CAAC,gBAAgB,iBAAiB,IAAI,SAAS,IAAI;AACzD,QAAM,CAAC,QAAQ,SAAS,IAAI,SAAS,oBAAI,IAAI,CAAC;AAK9C,QAAM,sBAAsB,OAAO,IAAI;AACvC,QAAM,iBAAiB,OAAO;AAAA,IAC5B,0BAA0B;AAAA,IAC1B,yBAAyB;AAAA,IACzB,4BAA4B;AAAA,IAC5B,cAAc,CAAC;AAAA,EACjB,CAAC;AAGD,QAAM,eAAe,OAAO;AAAA,IAC1B;AAAA,EACF,CAAC;AACD,YAAU,MAAM;AACd,iBAAa,QAAQ,WAAW;AAAA,EAClC,CAAC;AACD,QAAM,kCAAkC,OAAO,CAAC,CAAC;AAGjD,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAS,CAAC,CAAC;AAGrC,QAAM,0BAA0B,OAAO,oBAAI,IAAI,CAAC;AAChD,QAAM,eAAe,OAAO,CAAC;AAG7B,QAAM,qBAAqB,OAAO;AAAA,IAChC;AAAA,IACA,IAAI;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,sBAAoB,cAAc,OAAO;AAAA,IACvC,OAAO,MAAM;AAAA,IACb,WAAW,qBAAmB;AAC5B,YAAM;AAAA,QACJ,OAAAC;AAAA,QACA,OAAO;AAAA,MACT,IAAI,mBAAmB;AACvB,YAAMN,SAAQ,mBAAmB;AACjC,UAAIA,WAAU,UAAU;AACtB,cAAM,kBAAkB,4BAA4B,OAAO;AAC3D,eAAOM,OAAM,IAAI,UAAQ,OAAO,MAAM,eAAe;AAAA,MACvD,OAAO;AACL,eAAOA;AAAA,MACT;AAAA,IACF;AAAA,IACA,WAAW,CAACA,QAAO,oBAAoB;AACrC,YAAM;AAAA,QACJ,IAAIC;AAAA,QACJ,QAAAF;AAAA,QACA,OAAO;AAAA,QACP,OAAAL;AAAA,MACF,IAAI,mBAAmB;AACvB,WAAK,mBAAmBA,YAAW,UAAU;AAC3C,cAAM,kBAAkB,4BAA4BO,QAAO;AAC3D,QAAAD,SAAQA,OAAM,IAAI,UAAQ,OAAO,kBAAkB,GAAG;AAAA,MACxD;AACA,YAAM,+BAA+B,gCAAgC;AACrE,YAAM,cAAc,uBAAuBD,OAAM;AACjD,YAAM,YAAY,yBAAyB;AAAA,QACzC,SAAAE;AAAA,QACA,QAAAF;AAAA,QACA,WAAWC;AAAA,QACX;AAAA,QACA,OAAAN;AAAA,MACF,CAAC;AACD,UAAI,CAAC,SAAS,WAAW,SAAS,GAAG;AACnC,iBAAS,SAAS;AAClB,2BAAmB,aAAa,WAAW,4BAA4B;AAAA,MACzE;AAAA,IACF;AAAA,EACF,IAAI,CAAC,OAAO,CAAC;AACb,4BAA0B,MAAM;AAC9B,uBAAmB,QAAQ,YAAY;AACvC,uBAAmB,QAAQ,KAAK;AAChC,uBAAmB,QAAQ,SAAS;AACpC,uBAAmB,QAAQ,QAAQ;AACnC,uBAAmB,QAAQ,QAAQ;AAAA,EACrC,CAAC;AACD,sCAAoC;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAGD,YAAU,MAAM;AACd,UAAM;AAAA,MACJ,UAAAQ;AAAA,IACF,IAAI,aAAa;AACjB,UAAM;AAAA,MACJ,QAAAH;AAAA,MACA,OAAAC;AAAA,IACF,IAAI,mBAAmB;AAGvB,QAAIA,OAAM,SAAS,GAAG;AACpB,UAAIE,WAAU;AACZ,QAAAA,UAASF,MAAK;AAAA,MAChB;AACA,YAAM,+BAA+B,gCAAgC;AAOrE,YAAM,cAAc,uBAAuBD,OAAM;AACjD,yBAAmB,aAAaC,QAAO,4BAA4B;AAAA,IACrE;AAAA,EACF,GAAG,CAAC,KAAK,CAAC;AAKV,4BAA0B,MAAM;AAC9B,UAAM;AAAA,MACJ,IAAIC;AAAA,MACJ,OAAAD;AAAA,MACA,OAAAN;AAAA,IACF,IAAI,mBAAmB;AACvB,QAAIM,OAAM,WAAW,OAAO,MAAM;AAEhC;AAAA,IACF;AAIA,QAAI,eAAe;AACnB,QAAI,YAAY;AACd,YAAM,cAAc,uBAAuB,MAAM;AACjD,qBAAe,gBAAgB,YAAY,aAAa,OAAO;AAAA,IACjE;AACA,QAAI,gBAAgB,MAAM;AAGxB,YAAM,iBAAiB,yBAAyB;AAAA,QAC9C,SAAAC;AAAA,QACA;AAAA,QACA,WAAW;AAAA,QACX,WAAW;AAAA,QACX,OAAAP;AAAA,MACF,CAAC;AACD,eAAS,cAAc;AAAA,IACzB,OAAO;AACL,YAAMM,SAAQ,uBAAuB;AAAA,QACnC,SAAAC;AAAA,QACA;AAAA,QACA,OAAAP;AAAA,MACF,CAAC;AACD,eAASM,MAAK;AAAA,IAChB;AAAA,EACF,GAAG,CAAC,YAAY,QAAQ,OAAO,CAAC;AAChC,YAAU,MAAM;AAEd,QAAI,YAAY;AACd,UAAI,MAAM,WAAW,KAAK,MAAM,WAAW,OAAO,MAAM;AACtD;AAAA,MACF;AACA,YAAM,cAAc,uBAAuB,MAAM;AAGjD,UAAI,CAAC,YAAY,UAAU,GAAG;AAC5B,oBAAY,UAAU,IAAI,SAAS,sBAAsB,GAAG;AAAA,MAC9D;AACA,kBAAY,UAAU,EAAE,YAAY,aAAa,OAAO,OAAO;AAAA,IACjE;AACA;AACE,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,MACF,IAAI,eAAe;AACnB,UAAI,CAAC,yBAAyB;AAC5B,cAAM;AAAA,UACJ,QAAAD;AAAA,QACF,IAAI,mBAAmB;AACvB,cAAM,WAAW,MAAM,KAAKA,QAAO,KAAK,CAAC;AACzC,uBAAe,QAAQ,eAAe;AACtC,cAAM,oBAAoB,aAAa,SAAS,KAAK,CAAC,SAAS,cAAc,QAAQ;AACrF,YAAI,mBAAmB;AACrB,cAAI,MAAM,KAAKA,QAAO,OAAO,CAAC,EAAE,KAAK,WAAS,MAAM,QAAQ,sBAAsB,MAAM,QAAQ,SAAS,IAAI,GAAG;AAC9G,2BAAe,QAAQ,0BAA0B;AACjD,oBAAQ,KAAK,oFAAoF;AAAA,UACnG;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,GAAG,CAAC,YAAY,QAAQ,OAAO,OAAO,CAAC;AACvC,4BAA0B,MAAM;AAG9B,QAAI,UAAU,UAAU;AACtB,YAAM,iBAAiB,IAAI,eAAe,MAAM;AAC9C,cAAM;AAAA,UACJ,QAAAA;AAAA,UACA,OAAO;AAAA,QACT,IAAI,mBAAmB;AACvB,cAAM,YAAY,yBAAyB;AAAA,UACzC;AAAA,UACA,QAAAA;AAAA,UACA,WAAW;AAAA,UACX;AAAA,UACA;AAAA,QACF,CAAC;AACD,YAAI,CAAC,SAAS,WAAW,SAAS,GAAG;AACnC,mBAAS,SAAS;AAAA,QACpB;AAAA,MACF,CAAC;AACD,qBAAe,QAAQ,cAAc,OAAO,CAAC;AAC7C,aAAO,MAAM;AACX,uBAAe,WAAW;AAAA,MAC5B;AAAA,IACF;AAAA,EACF,GAAG,CAAC,SAAS,KAAK,CAAC;AACnB,QAAM,eAAe,YAAY,CAAC,IAAI,oBAAoB;AACxD,UAAM;AAAA,MACJ,QAAAA;AAAA,MACA,OAAO;AAAA,IACT,IAAI,mBAAmB;AACvB,UAAM,cAAc,uBAAuBA,OAAM;AACjD,UAAM,QAAQ,YAAY,UAAU,WAAS,MAAM,QAAQ,OAAO,EAAE;AACpE,UAAM,OAAO,MAAM,KAAK;AACxB,UAAML,SAAQ,mBAAmB;AACjC,QAAIA,WAAU,UAAU;AACtB,YAAM,kBAAkB,4BAA4B,OAAO;AAC3D,aAAO,OAAO,MAAM;AAAA,IACtB,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF,GAAG,CAAC,SAAS,KAAK,CAAC;AACnB,QAAM,gBAAgB,YAAY,CAAC,IAAI,gBAAgB;AACrD,UAAM;AAAA,MACJ,QAAAK;AAAA,IACF,IAAI,mBAAmB;AAKvB,QAAIA,QAAO,SAAS,GAAG;AACrB;AACE,YAAI,CAAC,eAAe,QAAQ,yBAA0B;AAAA,MACxD;AACA,aAAO;AAAA,QACL,WAAW;AAAA,QACX,UAAU,eAAe,OAAO,cAAc;AAAA,QAC9C,YAAY;AAAA;AAAA,QAEZ,UAAU;AAAA,MACZ;AAAA,IACF;AACA,UAAM,WAAW,YAAYA,SAAQ,IAAI,KAAK;AAC9C,WAAO;AAAA,MACL,WAAW;AAAA,MACX;AAAA,MACA,YAAY;AAAA;AAAA,MAEZ,UAAU;AAAA;AAAA;AAAA,MAGV,eAAe,oCAAoC,mBAAmB,OAAO,SAAS;AAAA,IACxF;AAAA,EACF,GAAG,CAAC,gBAAgB,kCAAkC,KAAK,CAAC;AAC5D,QAAM,gBAAgB,YAAY,CAAC,IAAI,aAAa;AAClD,UAAM;AAAA,MACJ,OAAAL;AAAA,IACF,IAAI,mBAAmB;AACvB,uBAAmBA,QAAO,QAAQ;AAClC,cAAU,gBAAc;AACtB,UAAI,WAAW,IAAI,EAAE,GAAG;AACtB,eAAO;AAAA,MACT;AACA,YAAM,aAAa,IAAI,IAAI,UAAU;AACrC,iBAAW,IAAI,IAAI,QAAQ;AAC3B,aAAO;AAAA,IACT,CAAC;AAAA,EACH,GAAG,CAAC,CAAC;AACL,QAAM,uBAAuB,YAAY,cAAY;AACnD,UAAM,gBAAgB,WAAS;AAC7B,YAAM,eAAe;AACrB,YAAM;AAAA,QACJ,WAAAS;AAAA,QACA,QAAAJ;AAAA,QACA,OAAO;AAAA,MACT,IAAI,mBAAmB;AACvB,YAAM,cAAc,uBAAuBA,OAAM;AACjD,YAAM,CAAC,UAAU,OAAO,IAAI,wBAAwB,SAAS,UAAU,WAAW;AAClF,UAAI,YAAY,QAAQ,WAAW,MAAM;AACvC;AAAA,MACF;AACA,UAAI,WAAW,YAAY,OAAO,SAAS,UAAU,aAAaI,YAAW,WAAW,oBAAoB,OAAO;AACnH,UAAI,aAAa,GAAG;AAClB;AAAA,MACF;AACA,YAAM,eAAe,cAAc,OAAO;AAC1C,YAAM,OAAO,aAAa,sBAAsB;AAChD,YAAM,eAAeA,eAAc;AAGnC,UAAI,SAAS,QAAQ,SAAS,cAAc;AAC1C,mBAAW,CAAC;AAAA,MACd;AACA,YAAM,OAAO,eAAe,KAAK,QAAQ,KAAK;AAC9C,YAAM,QAAQ,WAAW,OAAO;AAIhC,YAAM,YAAY,cAAc,OAAO,mBAAmB,SAAS,UAAU,SAAS,OAAO,WAAW,wBAAwB,SAAS,oBAAoB,OAAO;AACpK,YAAM,eAAe,CAAC,SAAS,WAAW,SAAS;AAGnD,UAAI,aAAa,KAAK,KAAK,aAAa,KAAK,GAAG;AAI9C,YAAI,aAAa,WAAW,OAAO;AACjC,cAAI,CAAC,cAAc;AAKjB,gBAAI,cAAc;AAChB,mCAAqB,WAAW,IAAI,mBAAmB,gBAAgB;AAAA,YACzE,OAAO;AACL,mCAAqB,WAAW,IAAI,iBAAiB,cAAc;AAAA,YACrE;AAAA,UACF,OAAO;AAEL,iCAAqB,eAAe,eAAe,UAAU;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AACA,UAAI,cAAc;AAChB,cAAM,+BAA+B,gCAAgC;AAGrE,iBAAS,SAAS;AAIlB,2BAAmB,aAAa,WAAW,4BAA4B;AAAA,MACzE;AACA,mBAAa,UAAU;AAAA,IACzB;AACA,WAAO;AAAA,EACT,GAAG,CAAC,OAAO,CAAC;AACZ,QAAM,kBAAkB,YAAY,QAAM;AACxC,cAAU,gBAAc;AACtB,UAAI,CAAC,WAAW,IAAI,EAAE,GAAG;AACvB,eAAO;AAAA,MACT;AACA,YAAM,aAAa,IAAI,IAAI,UAAU;AACrC,iBAAW,OAAO,EAAE;AACpB,aAAO;AAAA,IACT,CAAC;AAAA,EACH,GAAG,CAAC,CAAC;AACL,QAAM,gBAAgB,YAAY,QAAM;AACtC,UAAM;AAAA,MACJ,QAAAJ;AAAA,MACA,OAAO;AAAA,IACT,IAAI,mBAAmB;AACvB,UAAM,QAAQA,QAAO,IAAI,EAAE;AAC3B,QAAI,SAAS,MAAM;AACjB;AAAA,IACF;AACA,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,MAAM;AACV,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AACA,UAAM,cAAc,uBAAuBA,OAAM;AACjD,UAAM,QAAQ,YAAY,QAAQ,KAAK;AACvC,QAAI,QAAQ,GAAG;AACb;AAAA,IACF;AACA,UAAM,cAAc,UAAU,KAAK;AACnC,QAAI,gBAAgB,eAAe;AAEjC;AAAA,IACF;AACA,4BAAwB,QAAQ,IAAI,IAAI,WAAW;AACnD,UAAM,CAAC,UAAU,OAAO,IAAI,qBAAqB,IAAI,WAAW;AAChE,QAAI,YAAY,QAAQ,WAAW,MAAM;AACvC;AAAA,IACF;AACA,UAAM,cAAc,UAAU,YAAY,SAAS;AACnD,UAAM,QAAQ,cAAc,cAAc,gBAAgB;AAC1D,UAAM,YAAY,cAAc,MAAM,mBAAmB,SAAS,UAAU,SAAS,OAAO,WAAW,wBAAwB,SAAS,IAAI;AAC5I,QAAI,cAAc,WAAW;AAC3B,YAAM,+BAA+B,gCAAgC;AACrE,eAAS,SAAS;AAIlB,yBAAmB,aAAa,WAAW,4BAA4B;AAAA,IACzE;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,cAAc,YAAY,QAAM;AACpC,UAAM;AAAA,MACJ,QAAAA;AAAA,MACA,OAAO;AAAA,IACT,IAAI,mBAAmB;AACvB,UAAM,QAAQA,QAAO,IAAI,EAAE;AAC3B,QAAI,SAAS,MAAM;AACjB;AAAA,IACF;AACA,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,MAAM;AACV,UAAM,qBAAqB,wBAAwB,QAAQ,IAAI,EAAE,KAAK;AACtE,QAAI,CAAC,oBAAoB;AACvB;AAAA,IACF;AACA,UAAM,cAAc,uBAAuBA,OAAM;AACjD,UAAM,QAAQ,YAAY,QAAQ,KAAK;AACvC,QAAI,QAAQ,GAAG;AACb;AAAA,IACF;AACA,UAAM,cAAc,UAAU,KAAK;AACnC,QAAI,gBAAgB,eAAe;AAEjC;AAAA,IACF;AACA,UAAM,CAAC,UAAU,OAAO,IAAI,qBAAqB,IAAI,WAAW;AAChE,QAAI,YAAY,QAAQ,WAAW,MAAM;AACvC;AAAA,IACF;AACA,UAAM,cAAc,UAAU,YAAY,SAAS;AACnD,UAAM,QAAQ,cAAc,gBAAgB,qBAAqB;AACjE,UAAM,YAAY,cAAc,MAAM,mBAAmB,SAAS,UAAU,SAAS,OAAO,WAAW,wBAAwB,SAAS,IAAI;AAC5I,QAAI,cAAc,WAAW;AAC3B,YAAM,+BAA+B,gCAAgC;AACrE,eAAS,SAAS;AAIlB,yBAAmB,aAAa,WAAW,4BAA4B;AAAA,IACzE;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,cAAc,YAAY,CAAC,IAAI,UAAU,oBAAoB;AACjE,UAAM;AAAA,MACJ,IAAIE;AAAA,MACJ,QAAAF;AAAA,MACA,OAAO;AAAA,MACP,OAAAL;AAAA,IACF,IAAI,mBAAmB;AACvB,SAAK,mBAAmBA,YAAW,UAAU;AAC3C,YAAM,kBAAkB,4BAA4BO,QAAO;AAC3D,iBAAW,WAAW,kBAAkB;AAAA,IAC1C;AACA,UAAM,QAAQF,QAAO,IAAI,EAAE;AAC3B,QAAI,SAAS,MAAM;AACjB;AAAA,IACF;AACA,QAAI;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,MAAM;AACV,QAAIL,WAAU,UAAU;AACtB,YAAM,kBAAkB,4BAA4BO,QAAO;AAC3D,gBAAU,UAAU,kBAAkB;AACtC,UAAI,WAAW,MAAM;AACnB,kBAAU,UAAU,kBAAkB;AAAA,MACxC;AAAA,IACF;AACA,UAAM,cAAc,uBAAuBF,OAAM;AACjD,UAAM,QAAQ,YAAY,QAAQ,KAAK;AACvC,QAAI,QAAQ,GAAG;AACb;AAAA,IACF;AACA,UAAM,cAAc,UAAU,KAAK;AACnC,QAAI,gBAAgB,UAAU;AAC5B;AAAA,IACF;AACA,QAAI,eAAe,aAAa,cAAe;AAAA,SAAO;AACpD,YAAM,iBAAiB;AACvB,iBAAW,KAAK,IAAI,WAAW,OAAO,UAAU,KAAK,KAAK,IAAI,SAAS,QAAQ,CAAC;AAChF;AACE,YAAI,mBAAmB,UAAU;AAC/B,kBAAQ,MAAM,iBAAiB,cAAc,0BAA0B,MAAM,QAAQ,EAAE,8CAA8C;AAAA,QACvI;AAAA,MACF;AAAA,IACF;AACA,UAAM,CAAC,UAAU,OAAO,IAAI,qBAAqB,IAAI,WAAW;AAChE,QAAI,YAAY,QAAQ,WAAW,MAAM;AACvC;AAAA,IACF;AACA,UAAM,cAAc,UAAU,YAAY,SAAS;AACnD,UAAM,QAAQ,cAAc,cAAc,WAAW,WAAW;AAChE,UAAM,YAAY,cAAc,MAAM,mBAAmB,SAAS,UAAU,SAAS,OAAO,WAAW,wBAAwB,SAAS,IAAI;AAC5I,QAAI,cAAc,WAAW;AAC3B,YAAM,+BAA+B,gCAAgC;AACrE,eAAS,SAAS;AAIlB,yBAAmB,aAAa,WAAW,4BAA4B;AAAA,IACzE;AAAA,EACF,GAAG,CAAC,CAAC;AACL,QAAM,UAAU,QAAQ,OAAO;AAAA,IAC7B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,eAAe,CAAC,IAAI,UAAU;AAC5B,wBAAkB,EAAE;AACpB,UAAI,aAAa,KAAK,KAAK,aAAa,KAAK,GAAG;AAC9C,cAAM,gBAAgB,gBAAgB,EAAE;AACxC,4BAAoB,UAAU;AAAA,UAC5B,gBAAgB,cAAc,sBAAsB;AAAA,UACpD,YAAY,cAAc,OAAO,IAAI,SAAS;AAAA,UAC9C,OAAO,mBAAmB,QAAQ;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AAAA,IACA,cAAc,MAAM;AAClB,6BAAuB;AACvB,wBAAkB,IAAI;AACtB,0BAAoB,UAAU;AAAA,IAChC;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,CAAC,gBAAgB,eAAe,WAAW,aAAa,cAAc,eAAe,SAAS,eAAe,sBAAsB,aAAa,OAAO,eAAe,CAAC;AAC3K,QAAM,QAAQ;AAAA,IACZ,SAAS;AAAA,IACT,eAAe,cAAc,eAAe,QAAQ;AAAA,IACpD,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,OAAO;AAAA,EACT;AACA,SAAO,cAAc,kBAAkB,UAAU;AAAA,IAC/C,UAAU,cAAc,MAAM;AAAA,MAC5B;AAAA,MACA,WAAW;AAAA,MACX,oBAAoB;AAAA,MACpB,8BAA8B;AAAA,MAC9B,uBAAuB;AAAA,MACvB,0BAA0B;AAAA,MAC1B,OAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AAAA,IACD,OAAO;AAAA,EACT,CAAC;AACH;AACA,IAAM,aAAa,WAAW,CAAC,OAAO,QAAQ,cAAc,4BAA4B;AAAA,EACtF,GAAG;AAAA,EACH,cAAc;AAChB,CAAC,CAAC;AACF,2BAA2B,cAAc;AACzC,WAAW,cAAc;AAEzB,SAAS,kBAAkB;AAAA,EACzB,WAAW;AAAA,EACX,WAAW,qBAAqB;AAAA,EAChC,WAAW;AAAA,EACX,IAAI,cAAc;AAAA,EAClB;AAAA,EACA,OAAO,iBAAiB,CAAC;AAAA,EACzB,SAAS,OAAO;AAClB,GAAG;AACD,QAAM,gBAAgB,OAAO,IAAI;AAGjC,QAAM,eAAe,OAAO;AAAA,IAC1B;AAAA,EACF,CAAC;AACD,YAAU,MAAM;AACd,iBAAa,QAAQ,aAAa;AAAA,EACpC,CAAC;AACD,QAAM,oBAAoB,WAAW,iBAAiB;AACtD,MAAI,sBAAsB,MAAM;AAC9B,UAAM,MAAM,6EAA6E;AAAA,EAC3F;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,iBAAiB,YAAY,WAAW;AAC9C,QAAM,aAAa,mBAAmB;AACtC,QAAM,CAAC,WAAW,YAAY,IAAI,SAAS,KAAK;AAChD,QAAM,CAAC,eAAe,gBAAgB,IAAI,SAAS,IAAI;AACvD,QAAM,sBAAsB,YAAY,MAAM;AAG5C,UAAM,MAAM,cAAc;AAC1B,QAAI,KAAK;AACT,iBAAa;AACb,UAAM;AAAA,MACJ,YAAAK;AAAA,IACF,IAAI,aAAa;AACjB,QAAIA,aAAY;AACd,MAAAA,YAAW,KAAK;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,YAAY,CAAC;AACjB,YAAU,MAAM;AACd,QAAI,UAAU;AACZ,uBAAiB,IAAI;AAAA,IACvB,OAAO;AACL,YAAMC,iBAAgB,qBAAqB,cAAc;AACzD,uBAAiB,MAAMA,cAAa;AAAA,IACtC;AAAA,EACF,GAAG,CAAC,UAAU,gBAAgB,oBAAoB,CAAC;AACnD,YAAU,MAAM;AACd,QAAI,YAAY,iBAAiB,QAAQ,CAAC,YAAY;AACpD;AAAA,IACF;AACA,UAAM,SAAS,WAAS;AACtB,oBAAc,KAAK;AAAA,IACrB;AACA,UAAM,eAAe,WAAS;AAC5B,oBAAc,KAAK;AAAA,IACrB;AACA,UAAM,aAAa,cAAc;AACjC,UAAM,iBAAiB,WAAW;AAClC,mBAAe,KAAK,iBAAiB,eAAe,mBAAmB;AACvE,mBAAe,KAAK,iBAAiB,aAAa,MAAM;AACxD,mBAAe,KAAK,iBAAiB,aAAa,MAAM;AACxD,mBAAe,KAAK,iBAAiB,cAAc,YAAY;AAC/D,WAAO,iBAAiB,WAAW,mBAAmB;AACtD,WAAO,iBAAiB,YAAY,mBAAmB;AACvD,WAAO,MAAM;AACX,qBAAe,KAAK,oBAAoB,eAAe,mBAAmB;AAC1E,qBAAe,KAAK,oBAAoB,aAAa,MAAM;AAC3D,qBAAe,KAAK,oBAAoB,aAAa,MAAM;AAC3D,qBAAe,KAAK,oBAAoB,cAAc,YAAY;AAClE,aAAO,oBAAoB,WAAW,mBAAmB;AACzD,aAAO,oBAAoB,YAAY,mBAAmB;AAAA,IAC5D;AAAA,EACF,GAAG,CAAC,WAAW,UAAU,YAAY,eAAe,mBAAmB,CAAC;AACxE,yCAAuC;AAAA,IACrC;AAAA,IACA,UAAU;AAAA,IACV;AAAA,EACF,CAAC;AACD,QAAM,QAAQ;AAAA,IACZ,QAAQ,eAAe,SAAS;AAAA,IAChC,aAAa;AAAA,IACb,YAAY;AAAA,EACd;AACA,SAAO,cAAc,MAAM;AAAA,IACzB;AAAA,IACA,WAAW;AAAA,IACX,6BAA6B,aAAa,YAAY,YAAY,aAAa;AAAA,IAC/E,8BAA8B;AAAA,IAC9B,uBAAuB;AAAA,IACvB,oCAAoC,CAAC;AAAA,IACrC,+BAA+B;AAAA,IAC/B,QAAQ,MAAM,aAAa,KAAK;AAAA,IAChC,SAAS,MAAM,aAAa,IAAI;AAAA,IAChC,aAAa,WAAS;AACpB,oBAAc,gBAAgB,MAAM,WAAW;AAC/C,YAAM;AAAA,QACJ,YAAAD;AAAA,MACF,IAAI,aAAa;AACjB,UAAIA,aAAY;AACd,QAAAA,YAAW,IAAI;AAAA,MACjB;AAAA,IACF;AAAA,IACA,WAAW;AAAA,IACX,eAAe;AAAA,IACf,YAAY;AAAA,IACZ,cAAc,WAAS;AACrB,oBAAc,gBAAgB,MAAM,WAAW;AAC/C,YAAM;AAAA,QACJ,YAAAA;AAAA,MACF,IAAI,aAAa;AACjB,UAAIA,aAAY;AACd,QAAAA,YAAW,IAAI;AAAA,MACjB;AAAA,IACF;AAAA,IACA,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,IACA,UAAU;AAAA,EACZ,CAAC;AACH;AACA,kBAAkB,cAAc;",
  "names": ["units", "pivotId", "index", "panel", "element", "panels", "sizes", "groupId", "onLayout", "direction", "onDragging", "resizeHandler"]
}
